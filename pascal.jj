options {
	STATIC = false;
}

PARSER_BEGIN(Pascal)
import java.io.PrintStream; 
class Pascal {
	static public void main(String[] args)
	throws Exception {
		Pascal parser = new Pascal( System.in );
		parser.Start( System.out );
	}
}
PARSER_END(Pascal)


SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" }
SKIP : { < "{" > : IN_COMMENT }
<IN_COMMENT> SKIP : { < "}" > : DEFAULT | < ~[] > }
TOKEN : { < PROGRAM       : "program" > }
TOKEN : { < VAR           : "var" > }
TOKEN : { < BOOLEAN       : "boolean" > }
TOKEN : { < INTEGER       : "integer" > }
TOKEN : { < PROCEDURE     : "procedure" > }
TOKEN : { < BEGIN         : "begin" > }
TOKEN : { < END           : "end" > }
TOKEN : { < IF            : "if" > }
TOKEN : { < THEN          : "then" > }
TOKEN : { < ELSE          : "else" > }
TOKEN : { < WHILE         : "while" > }
TOKEN : { < DO            : "do" > }
TOKEN : { < CASE          : "case" > }
TOKEN : { < OF            : "of" > }
TOKEN : { < DIV           : "div" > }
TOKEN : { < AND           : "and" > }
TOKEN : { < NOT           : "not" > }
TOKEN : { < EQUAL         : "=" > }
TOKEN : { < ASSIGN        : ":=" > }
TOKEN : { < DIFFERENT     : "<>" > }
TOKEN : { < LESS          : "<" > }
TOKEN : { < LESS_EQUAL    : "<=" > }
TOKEN : { < GREATER_EQUAL : ">=" > }
TOKEN : { < GREATER       : ">" > }
TOKEN : { < PLUS          : "+" > }
TOKEN : { < MINUS         : "-" > }
TOKEN : { < TIMES         : "*" > }
TOKEN : { < OR            : "or" > }
TOKEN : { < TRUE          : "true" > }
TOKEN : { < FALSE         : "false"  > }
TOKEN : { < NUMBER        : (["0"-"9"])+ > }
TOKEN : { < READ          : "read" > }
TOKEN : { < WRITE         : "write" > }
TOKEN : { < IDENTIFIER    : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* > }
TOKEN : { < COMMA         : "," > }
TOKEN : { < SEMICOLON     : ";" > }
TOKEN : { < PERIOD        : "." > }
TOKEN : { < O_PAR         : "(" > }
TOKEN : { < C_PAR         : ")" > }
TOKEN : { < O_BRACKET     : "[" > }
TOKEN : { < C_BRACKET     : "]" > }
TOKEN : { < COLON         : ":" > }


void Start(PrintStream printStream):
{ Token t=null;}
{
	programa()
	<EOF>
	{

	}
}


/*1. <programa> ::= */
/*program <identificador> ;*/
/*<bloco>.*/
void programa(): {}
{
  <PROGRAM>
  <IDENTIFIER>
  <SEMICOLON>
  bloco()
  <PERIOD>
}


/*2. <bloco> ::= */
/*[<parte de declarações de variáveis>]*/
/*[<parte de declarações de procedimentos>]*/
/*<comando composto>*/
void bloco(): {}
{
	[parte_declaracao_variaveis()]
	[parte_declaracao_procedimento()]
	comando_composto()
}


/*3.   <tipo> ::= <identificador> */
void tipo(): {}
{
	<IDENTIFIER>
}

/*4. <constante> ::= [+|-] (<identificador> | <numero_inteiro>)*/
void constante(): {}
{
	[
		<PLUS>
		|
		<MINUS>
	]
	(
		<IDENTIFIER>
		|
		<NUMBER>
	)
}

/*5.  <parte de declarações de variáveis> ::=*/
/*var <declaração de variáveis> {; <declaração de variáveis>};*/
void parte_declaracao_variaveis(): {}
{
	<VAR>
	declaracao_variaveis()
	(
		LOOKAHEAD(2)
		<SEMICOLON>
		declaracao_variaveis()
	)*
	<SEMICOLON>
}



/*6. <declaração de variáveis>::=*/
/*<lista de identificadores> : <tipo>*/
void declaracao_variaveis(): {}
{
	lista_identificadores()
	<COLON>
	tipo()
}

/*7. <lista de identificadores> ::= <identificador> {, <identificador>}*/
void lista_identificadores(): {}
{
	<IDENTIFIER>
	(
		<COMMA>
		<IDENTIFIER>
	)*
}


/*8. <parte de declarações de procedimentos> ::=*/
/*{declaração de procedimento> ;}*/
void parte_declaracao_procedimento(): {}
{
		declaracao_procedimento()
}

/*9. <declaração de procedimento> ::=*/
/*procedure <identificador>*/
/*[<parâmetros formais>] ; <bloco>*/
void declaracao_procedimento(): {}
{
	<PROCEDURE>
	<IDENTIFIER>
	[parametros_formais()]
	<SEMICOLON>
	bloco()
}

/*10. <parâmetros formais> ::=*/
/*(<seção de parâmetros formais> { ; <seção de parâmetros formais>} )*/
void parametros_formais(): {}
{
	<O_PAR>
	secao_parametros_formais()
	(
		<SEMICOLON>
		secao_parametros_formais()
	)*
	<C_PAR>
}

/*11. <seção de parâmetros formais> ::=*/
/*[var] <lista de identificadores> : <identificador>*/
void secao_parametros_formais(): {}
{
	[<VAR>]
	lista_identificadores()
	<COLON>	
	<IDENTIFIER>
}

/*12. <comando composto> ::=  begin <comando> { ; <comando>} end*/
void comando_composto(): {}
{
	<BEGIN>
	comando()
	(
		<SEMICOLON>
		comando()
	)*
	<END>
}

/*	  13. <comado> ::=*/
/*	  <atribuição ou chamada de procedimento>*/
/*	  | <comando composto>*/
/*	  | <comando condicional 1>*/
/*	  | <comando condicional 2>*/
/*	  | <comando repetitivo 1>*/
void comando(): {}
{
	atribuicao_ou_chamada_de_procedimento()
	|
	comando_composto()
	|
	comando_condicional_1()
	|
	comando_condicional_2()
	|
	comando_repetitivo_1()
}

/*14. <atribuição ou chamada de procedimento>::= <identificador> <escolhe proced ou atrib>*/
void atribuicao_ou_chamada_de_procedimento(): {}
{
	<IDENTIFIER>
	escolhe_proced_ou_atrib()
}

/*15. <escolhe proced ou atrib> ::= <chamada de procedimento> | <atribuição>*/
void escolhe_proced_ou_atrib(): {}
{
	atribuicao()
	|
	chamada_procedimento()
}

/*16. <chamada de procedimento> ::= [ ( <lista de expressões> ) ]*/
void chamada_procedimento(): {}
{
	[
		<O_PAR>
		lista_expressoes()
		<C_PAR>
	]
}

/*17. <atribuição> ::= := <expressão>*/
void atribuicao(): {}
{
	<ASSIGN>
	expressao()
}

/*18. <comando condicional 1> ::=*/
/*if <expressão> then <comando>*/
/*[else <comando>]*/
void comando_condicional_1(): {}
{
	<IF>
	expressao()
	<THEN>
	comando()
	[
		LOOKAHEAD(2)
		<ELSE>
		comando()
	]
}

/*19. <comando condicional 2> ::=*/
/*case <expressão> of <elemento do case> */
/*{ ;  <elemento do case>} [else <comando>] end*/
void comando_condicional_2(): {}
{
	<CASE>
	expressao()
	<OF>
	elemento_case()
	(
		<SEMICOLON>
		elemento_case()
	)*
	[
		<ELSE>
		comando()
	]
	<END>
}

/*20. <elemento do case> ::= <constante>*/
/*{, constante>} : <comando>*/
void elemento_case(): {}
{
	constante()
	(
		<COMMA>
		constante()
	)*
	<COLON>
	comando()
}

/*21. <comando repetitivo 1> ::=*/
/*while <expressão> do <comando>*/
void comando_repetitivo_1(): {}
{
	<WHILE>
	expressao()
	<DO>
	comando()
}

/*22. <expressão> ::= <expressão simples> [<relação> <expressão simples>]*/
void expressao(): {}
{
	expressao_simples()
	[
		relacao()
		expressao_simples()
	]	
}

/*23. <relação> ::=   = | <> | < | <= | >= | >*/
void relacao(): {}
{
	<EQUAL>
	|
	<DIFFERENT>
	|
	<LESS>
	|
	<LESS_EQUAL>
	|
	<GREATER_EQUAL>
	|
	<GREATER>
}


/*24. <expressão simples> ::= */
/*[+ | -] <termo> {(+ | - | or) <termo>}*/
void expressao_simples(): {}
{
	[
		<PLUS>
		|
		<MINUS>
	]
	termo()
	(
		(
			<PLUS>
			|
			<MINUS>
			|
			<OR>
		)
		termo()
	)*
}

/*25. <termo> ::=*/
/*<fator> {(* | div | and ) <fator> }*/
void termo(): {}
{
	fator()
	(
		(
			<TIMES>
			|
			<DIV>
			|
			<AND>
		)
		fator()
	)*
}

/*26. <fator> ::=*/
/*<variavel>*/
/*| <número>*/
/*| ( <expressão> )*/
/*| not <fator>*/
void fator(): {}
{
	variavel()
	|
	<NUMBER>
	|
	<O_PAR> expressao() <C_PAR>
	|
	<NOT> fator()
}

/*27. <variável> ::= <identificador>*/
void variavel(): {}
{
	<IDENTIFIER>
}

/*28. <lista de expressões> ::=  <expressão> {, <expressão>}*/
void lista_expressoes(): {}
{
	expressao()
	(
		<COMMA>
		expressao()
	)*
}

